./test/read_from_fd.py 5 5<<EOF
cat author foo > tmp 2>&1
echo foobar >> tmp
exec 3<> tmp
cat <&3
echo ${} #sh ${}: bad substitution
echo `$((${$("'
echo $FOO
echo $0 #positional params not implemented
echo $HOME
echo ${0} #positional params not implemented
echo ${HOME}
echo "asdf"=
echo ${A-FOO} #default params not implemented
echo ${A=FOO} #default assign params not implemented
echo ${A?FOO} #error unset params not implemented
echo ${A+FOO} #alternative params not implemented
echo $((asdf"))=as
echo `asdf`=as
echo `=`
echo "="
echo '='
echo $(=)
echo $((=))
#============================
exec 6>&1           # Link file descriptor #6 with stdout, save stdout
exec > tmp_out_log     # stdout replaced with file "logfile.txt".
# ----------------------------------------------------------- #
# All output from commands in this block sent to file $LOGFILE.
echo -n "Logfile: "
date
echo "-------------------------------------"
echo
echo "Output of \"ls -al\" command"
echo
ls -al
echo; echo
echo "Output of \"df\" command"
echo
df
# ----------------------------------------------------------- #
exec 1>&6 6>&-      # Restore stdout and close file descriptor #6.
echo
echo "== stdout now restored to default == "
echo
ls -al
echo
#============================
echo \$(invalid)
echo \$((invalid))
exec > tmp_out
exec vim
ls
ls | head -2
ls | cat | head - 3
cat foo || echo this
cat foo && echo this
cat tmp_out && echo this
echo ${HOME}
cat author
cat foo
echo ${HOME}
echo $HOME
echo "HOME"
echo ${HOME}asdf'echo $HOME'$HOME'ignore$HOME'$HOME
echo \$HOME
echo $(((1 + 2) + 1))
echo "simple";
echo 'foo '"'"'bar'"'"'baz'"'"'bax'"'";
echo $FOO;
echo $(echo bar);
echo 	 	 "\nthis should not;
echo 	 	 "\nthis should not" ';
echo 	 	 "'\nthis should not';
echo "to stderr" 1>&2;
cat foo || echo not this
echo this && echo and this
echo this && echo and this || echo not this
echo this && cat foo || echo and this
cat foo || echo this && echo and this
echo \`invalid`
echo $(echo foo);
echo "\"l\
$($("foo"));
$((1 + 1));
echo ${echo foo};
(c)
{c}
echo `echo $HOME`
echo $
echo $(echo $)
echo ""
echo $(echo $HOME)
echo hello && echo world | tr a-z A-Z
# then you'll get
# hello
# WORLD
# back: tr a-z A-Z upper-cases its input, and you can see that
# only echo world was piped into it
# while echo hello went through on its own.
echo \2>a
# write character 2 into file a
echo 2\>a
# write characters 2>a to STDOUT
# UNTESTED
cat author && echo foo
./test/read_from_fd.py 0 <<EOF
cat	< author
echo \n; cat "foo";
	 	echo 	 	 "\nthis should"	 	"work";
echo	"\"this should"		\"too		;
ls -l -R | grep "\.txt$";
echo "foo bar" > test/out_file;
echo ${ENV};
cat << EOF;
