echo ${HOME}
echo $HOME
echo "HOME"
echo ${HOME}asdf'echo $HOME'$HOME'ignore$HOME'$HOME
echo \$HOME
echo $(((1 + 2) + 1))
echo "simple";
echo 'foo '"'"'bar'"'"'baz'"'"'bax'"'";
echo $FOO;
echo $(echo bar);
echo 	 	 "\nthis should not;
echo 	 	 "\nthis should not" ';
echo 	 	 "'\nthis should not';
echo "to stderr" 1>&2;
cat foo || echo not this
echo this && echo and this
echo this && echo and this || echo not this
echo this && cat foo || echo and this
cat foo || echo this && echo and this
echo \$(invalid)
echo \$((invalid))
echo \`invalid`
echo $(echo foo);
echo "\"l\
$($("foo"));
$((1 + 1));
echo ${echo foo};
(c)
{c}
echo `echo $HOME`
echo $
echo $(echo $)
echo ""
echo $(echo $HOME)
echo hello && echo world | tr a-z A-Z
# then you'll get
# hello
# WORLD
# back: tr a-z A-Z upper-cases its input, and you can see that
# only echo world was piped into it
# while echo hello went through on its own.
echo \2>a
# write character 2 into file a
echo 2\>a
# write characters 2>a to STDOUT
# UNTESTED
cat author && echo foo
./test/read_from_fd.py 0 <<EOF
cat	< author
echo \n; cat "foo";
	 	echo 	 	 "\nthis should"	 	"work";
echo	"\"this should"		\"too		;
ls -l -R | grep "\.txt$";
echo "foo bar" > test/out_file;
echo ${ENV};
cat << EOF;
